using CommonLayer; using CommonLayer.Entities.Built; using Accounts; using Foundation; using UIKit; using SQLite.Net; using SQLite.Net.Platform.XamarinIOS; using System; using CoreGraphics; using System.IO; using SQLiteNetExtensions.Extensions; using System.Collections.Generic; using System.Linq; using BuiltSDK; using System.Threading.Tasks; using CommonLayer.Entities;  namespace ConferenceAppiOS { 	// The UIApplicationDelegate for the application. This class is responsible for launching the 	// User Interface of the application, as well as listening (and optionally responding) to 	// application events from iOS. 	[Register("AppDelegate")] 	public partial class AppDelegate : UIApplicationDelegate 	{ 		public ACAccount twitterAccount { get; set; } 		public ACAccount accountStore { get; set; } 		public string hashtags { get; set; }  		public string sessionTwtter { get; set; }  		public string speakerTwtter { get; set; }  		public string sessiontwitterText { get; set; }  		public string speakertwitterText { get; set; }  		public BuiltConfig config;  		Router router; 		// class-level declarations 		static string dbPath = getDbPath(); 		static SQLiteConnectionPool pool; 		static SQLiteConnectionString cs;  		//private static SQLiteConnection connection; 		public static SQLiteConnection Connection 		{ 			get 			{ 				//if (connection == null) 				//{ 				//    connection = new SQLiteConnection(new SQLitePlatformIOS(), dbPath); 				//} 				//return connection;  				return pool.GetConnection(cs); 			} 		}  		NSDictionary launchOptions;  		public void openController(NSUrl url) 		{ 			if (router == null) 			{ 				router = new Router(); 			} 			router.openUrl(url); 		}  		public static AppDelegate instance() 		{ 			return (AppDelegate)UIApplication.SharedApplication.Delegate; 		}  		SplashScreen splashScreen; 		public RootViewController rootViewController { get; set; }  		public override UIWindow Window 		{ 			get; 			set; 		}  		public override bool FinishedLaunching(UIApplication application, NSDictionary launchOptions) 		{ 			RegisterRemoteNotifications(); 			SetupAsPerIniFile(); 			CopyDatabaseToLibraryFolder(AppSettings.dbFileName);  			UIApplication.SharedApplication.SetStatusBarStyle(UIStatusBarStyle.LightContent, false); 			UIApplication.SharedApplication.NetworkActivityIndicatorVisible = true; 			DataManager.IsActiveNetworkAvailable = Helper.IsConnectedToInternet; 			splashScreen = new SplashScreen(); 			splashScreen.DataLoaded = DataLoaded; 			Window.RootViewController = splashScreen; 			Window.MakeKeyAndVisible(); 			//processNotification(launchOptions, true); 			this.launchOptions = launchOptions; 			UIApplication.SharedApplication.ApplicationIconBadgeNumber = -1; 			return true; 		}  		private void DataLoaded() 		{ 			InvokeOnMainThread(() => 				{ 					rootViewController = new RootViewController(true); 					UINavigationController navigationController = new UINavigationController(rootViewController); 					Window.RootViewController = navigationController; 					processNotification(launchOptions, true); 				});  			//TitleHeaderView.previousTitle = TitleHeaderView.checkingUpdates; 			AppSettings.SyncState = TitleHeaderView.checkingUpdates; 			DataManager.CheckIfLatestDataAvailable(AppDelegate.Connection, (res) => 				{ 					if (res) 					{ 						//TitleHeaderView.previousTitle = TitleHeaderView.refreshTitleSelected; 						AppSettings.SyncState = TitleHeaderView.refreshTitleSelected; 						InvokeOnMainThread(() => 							{ 								//NSNotificationCenter.DefaultCenter.PostNotificationName(BaseViewController.LATEST_DATA_AVAILABLE, null); 								NSNotificationCenter.DefaultCenter.PostNotificationName(BaseViewController.StartDelta, null); 							}); 					} 					else 					{ 						//TitleHeaderView.previousTitle = TitleHeaderView.upToDate; 						AppSettings.SyncState = TitleHeaderView.upToDate; 						InvokeOnMainThread(() => 							{ 								NSUserDefaults.StandardUserDefaults.StringForKey(TitleHeaderView.timeStamp); 								NSNotificationCenter.DefaultCenter.PostNotificationName(BaseViewController.DATA_UP_TO_DATE, null); 							}); 					} 				}); 		}  		public void TriggerEvents() 		{ 			Task.Run(() => 				{ 					DataManager.GetEvents(Connection).ContinueWith(t => 						{ 							var props = DataManager.GetEventProperties(t.Result); 							if (props != null && props.Count > 0) 							{ 								InvokeOnMainThread(() => 									{ 										var superProperties = Helper.GetSuperProperties(); 										DataManager.TriggerMultipleEvents(Connection, props, superProperties, err => 											{ 											}); 									}); 							} 						}); 				}); 		}  		public void updateInstallation() 		{ 			try 			{ 				BuiltInstallation<BuiltInstallationData> ins = BuiltInstallation<BuiltInstallationData>.currentInstallation(); 				var token = ins.result.device_token; 				DataManager.CreateInstallation(token, err => { }, ins.result.disable); 			} 			catch 			{ } 		}  		private void RegisterRemoteNotifications() 		{ 			UIRemoteNotificationType notificationTypes = UIRemoteNotificationType.Alert | UIRemoteNotificationType.Badge; 			UIApplication.SharedApplication.RegisterForRemoteNotificationTypes(notificationTypes); 		}  		public override void RegisteredForRemoteNotifications(UIApplication application, NSData deviceToken) 		{ 			var token = deviceToken.ToString().Trim('<', '>').Replace(" ", ""); 			var previousToken = NSUserDefaults.StandardUserDefaults.StringForKey(AppSettings.DeviceTokenKey); 			if (token != previousToken) 			{ 				NSUserDefaults.StandardUserDefaults.SetString(token, AppSettings.DeviceTokenKey); 				DataManager.CreateInstallation(token, err => 					{ }); 			} 		}  		public override void ReceivedRemoteNotification(UIApplication application, NSDictionary userInfo) 		{ 			AppDelegate.instance().rootViewController.menuViewController.ShowNotificationBadge(true); 			DataManager.AddEventInfo(AppDelegate.Connection, AnalyticsEventIds.push_notifications, Helper.ToDateString(DateTime.Now)); 			processNotification(userInfo, false); 		}  		void processNotification(NSDictionary options, bool fromFinishedLaunching) 		{ 			if (fromFinishedLaunching) 			{ 				if (null != options && options.ContainsKey(new NSString("UIApplicationLaunchOptionsRemoteNotificationKey"))) 				{ 					//options = options.ObjectForKey(new NSString("UIApplicationLaunchOptionsRemoteNotificationKey")) as NSDictionary; 					NotificationViewController notificationViewController = new NotificationViewController(new CGRect(0, 0, 361, 655)); 					AppDelegate.instance().rootViewController.openInDialougueView(notificationViewController, DialogAlign.center); 					//notificationViewController.RefreshNotifications(); 				} 			}  			//Check to see if the dictionary has the aps key.  This is the notification payload you would have sent 			else if (null != options && options.ContainsKey(new NSString("aps"))) 			{ 				//Get the aps dictionary 				NSDictionary aps = options.ObjectForKey(new NSString("aps")) as NSDictionary;  				string alert = string.Empty; 				string sound = string.Empty; 				//int badge = -1;  				//Extract the alert text 				//NOTE: If you're using the simple alert by just specifying "  aps:{alert:"alert msg here"}  " 				//      this will work fine.  But if you're using a complex alert with Localization keys, etc., your "alert" object from the aps dictionary 				//      will be another NSDictionary... Basically the json gets dumped right into a NSDictionary, so keep that in mind 				if (aps.ContainsKey(new NSString("alert"))) 					alert = (aps[new NSString("alert")] as NSString).ToString();  				//Extract the sound string 				if (aps.ContainsKey(new NSString("sound"))) 					sound = (aps[new NSString("sound")] as NSString).ToString();  				//Extract the badge 				//                if (aps.ContainsKey(new NSString("badge"))) 				//                { 				//                    string badgeStr = (aps[new NSString("badge")] as NSObject).ToString(); 				//                    int.TryParse(badgeStr, out badge); 				//                }  				//If this came from the ReceivedRemoteNotification while the app was running, 				// we of course need to manually process things like the sound, badge, and alert. 				if (!fromFinishedLaunching) 				{ 					//Manually set the badge in case this came from a remote notification sent while the app was open 					//if (badge >= 0) 					//    UIApplication.SharedApplication.ApplicationIconBadgeNumber = badge; 					//Manually play the sound 					if (!string.IsNullOrEmpty(sound)) 					{ 						//This assumes that in your json payload you sent the sound filename (like sound.caf) 						// and that you've included it in your project directory as a Content Build type. 						var soundObj = AudioToolbox.SystemSound.FromFile(sound); 						soundObj.PlaySystemSound(); 					}  					//Manually show an alert 					if (!string.IsNullOrEmpty(alert)) 					{ 						UIAlertView avAlert = new UIAlertView("Notification", alert, null, "Close", "View"); 						avAlert.Clicked += (s, e) => 						{ 							if (e.ButtonIndex == 1) 							{ 								NotificationViewController notificationViewController = new NotificationViewController(new CGRect(0, 0, 361, 655)); 								AppDelegate.instance().rootViewController.openInDialougueView(notificationViewController, DialogAlign.center); 								notificationViewController.RefreshNotifications(); 							} 							else 							{ 								rootViewController.menuViewController.ShowNotificationBadge(true); 							} 						}; 						avAlert.Show(); 					} 				} 			} 		}  		public override void FailedToRegisterForRemoteNotifications(UIApplication application, NSError error) 		{ 		}  		// This method is invoked when the application is about to move from active to inactive state. 		// OpenGL applications should use this method to pause. 		public override void OnResignActivation(UIApplication application) 		{ 		}  		// This method should be used to release shared resources and it should store the application state. 		// If your application supports background exection this method is called instead of WillTerminate 		// when the user quits. 		public override void DidEnterBackground(UIApplication application) 		{ 			//TriggerEvents(); 		}  		// This method is called as part of the transiton from background to active state. 		public override void WillEnterForeground(UIApplication application) 		{ 			UIApplication.SharedApplication.ApplicationIconBadgeNumber = -1; 			DataManager.RefreshUserInfo(Connection, err => 				{ 					//TitleHeaderView.previousTitle = TitleHeaderView.checkingUpdates; 					AppSettings.SyncState = TitleHeaderView.checkingUpdates; 					InvokeOnMainThread(() => 						{ 							NSNotificationCenter.DefaultCenter.PostNotificationName(BaseViewController.CHECKING_UPDATE, null); 						});  					DataManager.CheckIfLatestDataAvailable(AppDelegate.Connection, (res) => 						{ 							if (res) 							{ 								//TitleHeaderView.previousTitle = TitleHeaderView.refreshTitleSelected; 								AppSettings.SyncState = TitleHeaderView.refreshTitleSelected; 								InvokeOnMainThread(() => 									{ 										//NSNotificationCenter.DefaultCenter.PostNotificationName(BaseViewController.LATEST_DATA_AVAILABLE, null); 										NSNotificationCenter.DefaultCenter.PostNotificationName(BaseViewController.StartDelta, null); 									}); 							} 							else 							{ 								//TitleHeaderView.previousTitle = TitleHeaderView.upToDate; 								AppSettings.SyncState = TitleHeaderView.upToDate; 								InvokeOnMainThread(() => 									{ 										NSNotificationCenter.DefaultCenter.PostNotificationName(BaseViewController.DATA_UP_TO_DATE, null); 									}); 							} 						});  					//var user = DataManager.GetCurrentUser(connection).Result; 					if (AppSettings.ApplicationUser != null) 					{ 						DataManager.fetchExtensionsData(Connection, AppSettings.ApplicationUser, res => 							{ 								InvokeOnMainThread(() => 									{ 										NSNotificationCenter.DefaultCenter.PostNotificationName(BaseViewController.AFTER_LOGIN_DATA_FETCHED, null); 									}); 							}); 					} 				});  			TriggerEvents(); 			updateInstallation(); 		}  		// This method is called when the application is about to terminate. Save data, if needed. 		public override void WillTerminate(UIApplication application) 		{ 		}  		public void ShowLogin() 		{ 			LoginViewController vc = new LoginViewController(new CGRect(0, 0, AppTheme.LoginWidth, AppTheme.LoginHeight)); 			AppDelegate.instance().rootViewController.openInDialougueView(vc, DialogAlign.center); 		}  		private void CopyDatabaseToLibraryFolder(string filename) 		{ 			//---path to Documents folder--- 			var documentsPath = 				Environment.GetFolderPath( 					Environment.SpecialFolder.Personal);  			string libraryPath = Path.Combine(documentsPath, "..", "Library", "Application Support"); // Library folder  			if (!Directory.Exists(libraryPath)) 				Directory.CreateDirectory(libraryPath);  			NSError error = NSFileManager.SetSkipBackupAttribute(libraryPath, true);   			//---destination path for file in the Documents 			// folder--- 			var destinationPath = 				Path.Combine(libraryPath, filename); 			dbPath = destinationPath;  			pool = new SQLiteConnectionPool(new SQLitePlatformIOS()); 			cs = new SQLiteConnectionString(dbPath, false);  			//---path of source file--- 			var sourcePath = 				Path.Combine(NSBundle.MainBundle.BundlePath, 					filename);  			//---print for verfications--- 			//            Console.WriteLine(destinationPath); 			//            Console.WriteLine(sourcePath);  			try 			{ 				//---copy only if file does not exist--- 				if (!File.Exists(destinationPath)) 				{ 					File.Copy(sourcePath, destinationPath); 				} 				else 				{ 					Console.WriteLine("File already exists"); 				} 			} 			catch (Exception e) 			{ 				Console.WriteLine(e.Message); 			} 		}  		static string getDbPath() 		{ 			var documentsPath = 				Environment.GetFolderPath( 					Environment.SpecialFolder.Personal);  			string libraryPath = Path.Combine(documentsPath, "..", "Library", "Application Support"); // Library folder  			if (!Directory.Exists(libraryPath)) 				Directory.CreateDirectory(libraryPath);   			var destinationPath = 				Path.Combine(libraryPath, AppSettings.dbFileName); 			dbPath = destinationPath; 			return dbPath; 		}  		void SetupAsPerIniFile() 		{ 			var configPath = Path.Combine(NSBundle.MainBundle.BundlePath, "config.ini"); 			INIFile readfile = new INIFile(configPath, false, true); 			string environment = readfile.GetValue("defaults", "environment", String.Empty); 			string apiKey = readfile.GetValue(environment, "api_key", String.Empty); 			string appUid = readfile.GetValue(environment, "app_uid", String.Empty); 			string credentials_name = readfile.GetValue(environment, "credentials_name", String.Empty); 			DataManager.Initialize(apiKey, appUid, credentials_name);  			var db_name = readfile.GetValue(environment, "db_name", String.Empty); 			if (!String.IsNullOrWhiteSpace(db_name)) 				AppSettings.dbFileName = db_name;  			string appId = readfile.GetValue(environment, "crittercism_key", String.Empty); 			if (!String.IsNullOrWhiteSpace(appId)) 				CrittercismIOS.Crittercism.Init(appId); 		} 	} } 